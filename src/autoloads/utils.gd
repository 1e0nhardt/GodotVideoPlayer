extends Node

const ASS_TEMPLATE = """[Script Info]
; Script generated by 1e0nhardt's bilingual subtitle tool
; https://github.com/1e0nhardt/BilinguSubs
ScriptType: v4.00+
ScaledBorderAndShadow: Yes
PlayResX: 1920
PlayResY: 1080
WrapStyle: 0

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: EN,Resource Han Rounded CN Regular,40,&H00FFFFFF,&HF0000000,&H00000000,&H32000000,0,0,0,0,100,100,0,0,1,2,1,2,5,5,15,1
Style: ZH,Resource Han Rounded CN Regular,64,&H00FFFFFF,&HF00000FF,&H00000000,&H32000000,-1,0,0,0,100,100,0,0,1,2,1,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""

const ASS_DIALOG_FORMAT = "Dialogue: %d,%s,%s,ZH,,0,0,0,,%s\\N{\\rEN}%s\n"
const ASS_DIALOG_FORMAT_ONLY_FIRST = "Dialogue: %d,%s,%s,ZH,,0,0,0,,%s\n"

var start_time: int


func get_suffix(filepath: String) -> String:
    return filepath.rsplit(".", true, 1)[1].to_lower()


func get_parent_dir(filepath: String) -> String:
    return filepath.rsplit("/", true, 1)[0]


func get_stem(filepath: String) -> String:
    return filepath.rsplit("/", true, 1)[1].split(".")[0]


func reset_start_time():
    start_time = Time.get_ticks_usec()


@warning_ignore("integer_division")
func print_time_cost(desc: String="Segment"):
    var msg := ""
    var time_cost: int = Time.get_ticks_usec() - start_time
    var us = time_cost - time_cost / 1000 * 1000
    time_cost /= 1000
    if time_cost == 0:
        msg = "%s time cost: %dus" % [desc, us]
    else:
        var ms = time_cost - time_cost / 1000 * 1000
        time_cost /= 1000
        if time_cost == 0:
            msg = "%s time cost: %d_%03dus" % [desc, ms, us]
        else:
            msg = "%s time cost: %d_%03d_%03dus" % [desc, time_cost, ms, us]
    Logger.info(msg)


@warning_ignore("integer_division")
func time_float2str(time: float, format="ass") -> String:
    var seconds: int = int(time)
    var ms = time - seconds
    if format == "ass":
        ms = int(ms * 100)
    else:
        ms = int(ms * 1000)
    var minutes = seconds / 60
    seconds %= 60
    var hours = minutes / 60
    minutes %= 60
    if format == "ass":
        return "%02d:%02d:%02d.%02d" % [hours, minutes, seconds, ms]
    else:
        return "%02d:%02d:%02d,%03d" % [hours, minutes, seconds, ms]


func time_str2float(time_str: String, format="ass") -> float:
    var tmp_arr = time_str.strip_edges().split(':')
    var hrs = tmp_arr[0]
    var mins = tmp_arr[1]
    var sec_ms = tmp_arr[2]
    var seconds
    var ms
    if format == "ass":
        tmp_arr = sec_ms.split(".")
        tmp_arr[1] += "0"
    else:
        tmp_arr = sec_ms.split(",")
    seconds = tmp_arr[0]
    ms = tmp_arr[1]
    return float(int(hrs) * 3600 + int(mins) * 60 + int(seconds)) + int(ms)/1000.0


func parse_subtitle_file(filepath: String) -> Array[SubtitleClip]:
    var content = FileAccess.get_file_as_string(filepath)
    if get_suffix(filepath) == "ass":
        return parse_ass_file(content)
    elif get_suffix(filepath) == "list":
        return parse_list_file(content)
    else:
        Logger.warn("Not supportted format %s" % get_suffix(filepath))
        return []


func parse_ass_file(content: String) -> Array[SubtitleClip]:
    var subtitle_clips: Array[SubtitleClip] = []
    var current_section = ""
    var lines: Array = content.split("\n")
    var line_text: String
    for i in lines.size():
        line_text = lines[i]
        if i == 0:
            # 文件开头可能有BOM头\ufeff，因此用==判断会出错
            assert("[Script Info]" in line_text, "ass文件内容格式错误")
            continue

        if line_text.strip_edges() == "[V4+ Styles]":
            current_section = "style"
            continue
        elif line_text.strip_edges() == "[Events]":
            current_section = "events"
            continue
        elif line_text.begins_with("Format"):
            continue

        if current_section == "events":
            if line_text.strip_edges() == "" or line_text.begins_with("Comment"):
                continue
            elif line_text.begins_with("Dialogue"):
                var subtitle_clip := SubtitleClip.new()
                var params = line_text.split(": ", true, 1)[1].split(",", true, 9)
                subtitle_clip.start = params[1]
                subtitle_clip.end = params[2]
                var subtitle_text = params[9]
                #Logger.debug("%s" % subtitle_text)
                if subtitle_text.find("\\N{\\rEN}") != -1:
                    subtitle_clip.first_text = subtitle_text.split("\\N{\\rEN}")[0]
                    subtitle_clip.second_text = subtitle_text.split("\\N{\\rEN}")[1]
                else:
                    subtitle_clip.second_text = params[9]
                subtitle_clips.append(subtitle_clip)
            else:
                Logger.warn("ASS FORMAT INVALID at %d: %s" % [i, lines[i]])
        elif current_section == "style":
            continue
            #if line_text.begins_with("Style"):
                #var params = line_text.split(": ")[1].split(",")
                #self.valid_style_names.append(params[0])
        else:
            continue

    return subtitle_clips


func parse_list_file(content: String) -> Array[SubtitleClip]:
    var subtitle_clips: Array[SubtitleClip] = []
    var reg = RegEx.create_from_string(r"\[(.*)->(.*)\](.*)")
    var reg_match: RegExMatch
    for line in content.strip_edges().split("\n"):
        var subtitle_clip = SubtitleClip.new()
        reg_match = reg.search(line)
        if reg_match:
            subtitle_clip.start = time_float2str(float(reg_match.get_string(1)))
            subtitle_clip.end = time_float2str(float(reg_match.get_string(2)))
            subtitle_clip.second_text = reg_match.get_string(3)
            subtitle_clips.append(subtitle_clip)
        else:
            Logger.warn("Invalid line! => %s" % line)
            break
    return subtitle_clips


func parse_edit_text(content: String) -> Array[SubtitleClip]:
    var subtitle_clips: Array[SubtitleClip] = []
    var lines: Array = content.split("\n")
    var treg := RegEx.new()
    var reg_match: RegExMatch
    treg.compile(r"\[(.*)->(.*)\]")

    var i = 0
    while i < lines.size():
        var subtitle_clip = SubtitleClip.new()
        # 时间行
        reg_match = treg.search(lines[i].strip_edges())
        if reg_match:
            subtitle_clip.start = reg_match.get_string(1)
            subtitle_clip.end = reg_match.get_string(2)
        else:
            Logger.warn("Time label is invalid! => %s" % lines[i])
        i += 1
        # 第一语言字幕
        subtitle_clip.first_text = lines[i].strip_edges()
        i += 1
        # 第二语言字幕
        subtitle_clip.second_text = lines[i].strip_edges()
        i += 1
        subtitle_clips.append(subtitle_clip)

        # 跳过空行
        while i < lines.size() and lines[i].strip_edges() == "":
            i += 1

    return subtitle_clips
